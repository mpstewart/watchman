#!/usr/bin/perl
use strict;
use warnings;
use utf8;
use v5.10;

use autodie qw( open close );

# set up local libs
use FindBin;
use lib "$FindBin::Bin/../local/lib/perl5";

use AnyEvent::Filesys::Notify;
use AnyEvent;
use Capture::Tiny qw( capture_merged );
use Cwd;
use IO::Handle;
use POSIX ":sys_wait_h";
use Scalar::Util qw( openhandle );
use Term::ANSIColor qw( :constants );

my $CMD = do {
  shift @ARGV if $ARGV[0] eq '--';
  join " ", @ARGV;
};

my $runner_chan = AnyEvent->condvar;
sub main {
  my $cwd = getcwd;

  print "Q to quit. R to run command again.\n";

  my $file_notifier = AnyEvent::Filesys::Notify->new(
    dirs         => [ $cwd ],
    filter       => qr{\.(?:pm|pl|t)$},
    cb           => \&handle,
    parse_events => 1,  # Improves efficiency on certain platforms
  );

  AnyEvent->condvar->recv;
}

# handle will handle events, but also the lifecycles of our child processes;
# upon receiving a file write event:
# 1) Any existing children will be sent the INT signal, which they may catch and
#    use to clean up any in-progress work they may have going. Handle will wait
#    for any existing children to exit before we spawn new children
# 2) A new child process will be forked, which will run the user's command
sub handle {
  my $event = shift;
  return unless $event->is_created;

  state $par = 0; $par++;

  # $runner_pid, as a state variable, will cache the PID of any child we create
  # upon event handling; this allows us to send our children the interrupt
  # signal, which will cause them to clean up their own children. This also
  # allows us to perform the necessarily blocking waitpid call
  state $runner_pid;
  if ($runner_pid) {
    kill 'INT', $runner_pid;
    waitpid $runner_pid, 0;
  }

  # fork, and cache the PID so we can clean it up if we catch an event in the
  # meantime
  $runner_pid = fork();

  # if we are the child, then run the user's command
  run_command($par)
    unless $runner_pid;
}


# run_command will run the user's command, catching STDOUT and STDERR, then
# feed that STDOUT and STDERR to an instance of less. run_command runs entirely
# as a child process, so this function installs an INT handler, which it will
# run in response to our parent catching a new file write event.
sub run_command {
  my $par = shift;

  my $merged = capture_merged {
    # script is some magic to make colors work on some platforms
    system(qq(script --quiet -c "$CMD" /dev/null));
  };

  my $less_fh;
  my $less_pid = open $less_fh, "|less -KR";
  if ($less_pid) {
    $SIG{INT} = sub {
      kill 'KILL', $less_pid;
      waitpid $less_pid, 0;
      system('clear');
      exit 0;
    };

    print $less_fh header($par);
    print $less_fh $merged;
  }

  else {
    # we're in the child process that's running less; just die if it finishes,
    # our parent will reap us
    exit 0;
  }
}

sub header {
  my ( $par) = @_;

  my $header = sprintf(<<TEMPLATE,
%s
# cmd: %s
# par: %d
%s
TEMPLATE
    join(("-") x 60),
    $CMD,
    $par,
    join(("-") x 60),
  );

  return $header;
}

main();
